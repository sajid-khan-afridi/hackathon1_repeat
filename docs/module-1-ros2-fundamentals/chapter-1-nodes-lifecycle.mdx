---
title: "Chapter 1: ROS 2 Nodes & Lifecycle"
sidebar_position: 1
description: "Learn how to create ROS 2 nodes, understand node lifecycle states, and implement lifecycle callbacks for robust robotics applications"
keywords:
  - ROS2
  - nodes
  - lifecycle
  - rclpy
  - rclcpp
  - managed nodes
  - callbacks
tags:
  - ros2
  - fundamentals
  - nodes
  - lifecycle
learning_objectives:
  - "Create ROS 2 nodes using rclpy (Python) and rclcpp (C++)"
  - "Understand and implement the four primary node lifecycle states"
  - "Configure lifecycle callbacks for state transitions"
  - "Debug common node initialization issues"
difficulty_level: beginner
ros_version: humble
prerequisites: []
estimated_time: 60
personalization_variants:
  experience_level: true
  ros_familiarity: true
  hardware_access: false
---

# Chapter 1: ROS 2 Nodes & Lifecycle

## Introduction

In ROS 2, a **node** is the fundamental building block of any robotics application. It's a process that performs computation and communicates with other nodes using the ROS 2 communication infrastructure. Understanding nodes and their lifecycle is crucial for building robust robotics systems.

<PersonalizedSection level="beginner" rosFamiliarity="novice">
Think of a node as a small program that does one specific job in your robot system. For example, one node might handle sensor data, another might control motors, and a third might process commands from a user.
</PersonalizedSection>

<PersonalizedSection level="advanced" rosFamiliarity="expert">
In ROS 2, nodes are more than just processes—they're containers for computation that participate in a distributed graph of data flow. They implement the ROS 2 DDS-based communication middleware and can be composed into complex systems with sophisticated dependency management.
</PersonalizedSection>

## 1.1 Creating Your First Node

Let's start by creating a simple "hello world" node that demonstrates the basic structure.

<PersonalizedSection language="python">

### Python Implementation

```python
# test: true
# ROS 2 Humble | Python 3.10+
# Dependencies: rclpy
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node

class HelloWorldNode(Node):
    """A simple ROS 2 node that prints hello world messages."""

    def __init__(self):
        # Initialize the node with the name 'hello_world_node'
        super().__init__('hello_world_node')

        # Log a message to indicate the node has started
        self.get_logger().info('Hello World Node has been started!')

        # Create a timer to call the timer_callback every second
        self.timer = self.create_timer(1.0, self.timer_callback)
        self.counter = 0

    def timer_callback(self):
        """Timer callback that prints a message every second."""
        self.counter += 1
        msg = f'Hello World! Count: {self.counter}'
        self.get_logger().info(msg)

def main(args=None):
    """Main function to run the node."""
    rclpy.init(args=args)

    # Create the node instance
    node = HelloWorldNode()

    try:
        # Spin the node so callbacks are called
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        # Clean up
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

</PersonalizedSection>

<PersonalizedSection language="cpp">

### C++ Implementation

```cpp
// test: true
// ROS 2 Humble | C++17
// Dependencies: rclcpp
#include <chrono>
#include <memory>
#include "rclcpp/rclcpp.hpp"

using namespace std::chrono_literals;

class HelloWorldNode : public rclcpp::Node
{
public:
  HelloWorldNode() : Node("hello_world_node")
  {
    // Log a message to indicate the node has started
    RCLCPP_INFO(this->get_logger(), "Hello World Node has been started!");

    // Create a timer to call the timer_callback every second
    timer_ = this->create_wall_timer(
      1s, std::bind(&HelloWorldNode::timer_callback, this));

    counter_ = 0;
  }

private:
  void timer_callback()
  {
    ++counter_;
    RCLCPP_INFO(this->get_logger(), "Hello World! Count: %d", counter_);
  }

  rclcpp::TimerBase::SharedPtr timer_;
  int counter_;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);

  // Create the node instance
  auto node = std::make_shared<HelloWorldNode>();

  // Spin the node so callbacks are called
  rclcpp::spin(node);

  // Clean up
  rclcpp::shutdown();
  return 0;
}
```

</PersonalizedSection>

## 1.2 Node Lifecycle States

ROS 2 nodes have a well-defined lifecycle with several states. Understanding these states is essential for managing resources and ensuring proper startup/shutdown procedures.

<PersonalizedSection level="beginner">
The node lifecycle is like the life cycle of a living thing - it starts (configures), becomes active (activates), can be put to sleep (deactivates), and eventually shuts down cleanly.
</PersonalizedSection>

### Primary Lifecycle States

1. **Unconfigured**: Initial state after node creation
2. **Inactive**: Configured but not actively processing
3. **Active**: Actively processing data and performing computations
4. **Finalized**: Cleaned up and ready for destruction

### Managed Node Example

Let's create a managed node using the ROS 2 lifecycle system:

```python
# test: true
# ROS 2 Humble | Python 3.10+
# Dependencies: rclpy, lifecycle_msgs
import rclpy
from rclpy.lifecycle import LifecycleNode, TransitionCallbackReturn
from rclpy.lifecycle import State, Transition

class ManagedNode(LifecycleNode):
    """A managed ROS 2 node demonstrating lifecycle states."""

    def __init__(self):
        super().__init__('managed_node')
        self.get_logger().info('ManagedNode created')

    def on_configure(self, state: State) -> TransitionCallbackReturn:
        """Called when transitioning from 'unconfigured' to 'inactive'."""
        self.get_logger().info('Configuring node...')
        # Initialize resources here
        self.counter = 0
        self.get_logger().info('Node configured successfully')
        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state: State) -> TransitionCallbackReturn:
        """Called when transitioning from 'inactive' to 'active'."""
        self.get_logger().info('Activating node...')
        # Activate publishers/subscribers here
        self.get_logger().info('Node activated successfully')
        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, state: State) -> TransitionCallbackReturn:
        """Called when transitioning from 'active' to 'inactive'."""
        self.get_logger().info('Deactivating node...')
        # Deactivate publishers/subscribers here
        self.get_logger().info('Node deactivated successfully')
        return TransitionCallbackReturn.SUCCESS

    def on_cleanup(self, state: State) -> TransitionCallbackReturn:
        """Called when transitioning from 'inactive' to 'unconfigured'."""
        self.get_logger().info('Cleaning up node...')
        # Clean up resources here
        del self.counter
        self.get_logger().info('Node cleaned up successfully')
        return TransitionCallbackReturn.SUCCESS

    def on_shutdown(self, state: State) -> TransitionCallbackReturn:
        """Called when shutting down the node."""
        self.get_logger().info('Shutting down node...')
        # Final cleanup here
        self.get_logger().info('Node shut down successfully')
        return TransitionCallbackReturn.SUCCESS

def main(args=None):
    rclpy.init(args=args)

    # Create the managed node
    managed_node = ManagedNode()

    try:
        rclpy.spin(managed_node)
    except KeyboardInterrupt:
        pass
    finally:
        managed_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## 1.3 Common Node Patterns

### Parameter Node

Nodes often need to be configurable using parameters:

```python
# test: true
# ROS 2 Humble | Python 3.10+
# Dependencies: rclpy
import rclpy
from rclpy.node import Node

class ParameterNode(Node):
    """A node that demonstrates parameter handling."""

    def __init__(self):
        super().__init__('parameter_node')

        # Declare parameters with default values
        self.declare_parameter('update_frequency', 10.0)
        self.declare_parameter('message_prefix', 'ROS 2')
        self.declare_parameter('debug_mode', False)

        # Get parameter values
        self.frequency = self.get_parameter('update_frequency').value
        self.prefix = self.get_parameter('message_prefix').value
        self.debug = self.get_parameter('debug_mode').value

        # Add parameter callback for dynamic updates
        self.add_on_set_parameters_callback(self.parameters_callback)

        # Create timer based on frequency parameter
        self.timer = self.create_timer(1.0 / self.frequency, self.timer_callback)

        self.get_logger().info(f'Node started with frequency: {self.frequency} Hz')

    def parameters_callback(self, parameters):
        """Handle parameter updates."""
        for param in parameters:
            if param.name == 'update_frequency':
                if param.type_ == Parameter.Type.DOUBLE:
                    # Update timer frequency
                    self.frequency = param.value
                    self.timer.destroy()
                    self.timer = self.create_timer(1.0 / self.frequency, self.timer_callback)
                    self.get_logger().info(f'Updated frequency to {self.frequency} Hz')

            elif param.name == 'debug_mode':
                if param.type_ == Parameter.Type.BOOL:
                    self.debug = param.value
                    self.get_logger().info(f'Debug mode: {"ON" if self.debug else "OFF"}')

        return SetParametersResult(successful=True)

    def timer_callback(self):
        """Periodic callback."""
        if self.debug:
            self.get_logger().debug(f'Timer callback at {self.frequency} Hz')
        # Node logic here

def main(args=None):
    rclpy.init(args=args)
    node = ParameterNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Exercises

### Exercise 1.1: Create a Sensor Node (Beginner)

**Learning Objective**: Apply node creation concepts to build a simulated sensor node

#### Problem
Create a ROS 2 node that simulates a temperature sensor. The node should:
- Publish temperature readings every 2 seconds
- Temperature should vary between 20-25°C
- Include a unique node name

#### Starter Code
```python
# Complete this implementation
import rclpy
from rclpy.node import Node
import random
import time

class TemperatureSensorNode(Node):
    def __init__(self):
        # TODO: Initialize node with unique name
        super().__init__('temperature_sensor')

        # TODO: Create timer for 2 second interval

    def timer_callback(self):
        # TODO: Generate random temperature between 20-25
        # TODO: Log the temperature reading

        pass
```

#### Solution
```python
# test: true
import rclpy
from rclpy.node import Node
import random
import time

class TemperatureSensorNode(Node):
    def __init__(self):
        super().__init__('temperature_sensor_' + str(random.randint(1000, 9999)))
        self.get_logger().info(f'Temperature sensor node started: {self.get_name()}')

        self.timer = self.create_timer(2.0, self.timer_callback)

    def timer_callback(self):
        temp = round(random.uniform(20.0, 25.0), 1)
        self.get_logger().info(f'Temperature: {temp}°C')

def main(args=None):
    rclpy.init(args=args)
    node = TemperatureSensorNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Expected Output
```
[INFO] [temperature_sensor_3847]: Temperature sensor node started: temperature_sensor_3847
[INFO] [temperature_sensor_3847]: Temperature: 23.4°C
[INFO] [temperature_sensor_3847]: Temperature: 21.2°C
[INFO] [temperature_sensor_3847]: Temperature: 24.8°C
```

### Exercise 1.2: Implement Node with Multiple Timers (Beginner)

**Learning Objective**: Understand how to manage multiple periodic tasks in a single node

#### Problem
Create a node that has two timers:
- Fast timer: Fires every 0.5 seconds, prints "Fast tick"
- Slow timer: Fires every 2 seconds, prints "Slow tick"

#### Solution
```python
# test: true
import rclpy
from rclpy.node import Node

class MultiTimerNode(Node):
    def __init__(self):
        super().__init__('multi_timer_node')

        self.fast_timer = self.create_timer(0.5, self.fast_callback)
        self.slow_timer = self.create_timer(2.0, self.slow_callback)

        self.fast_count = 0
        self.slow_count = 0

        self.get_logger().info('Multi-timer node started')

    def fast_callback(self):
        self.fast_count += 1
        self.get_logger().info(f'Fast tick #{self.fast_count}')

    def slow_callback(self):
        self.slow_count += 1
        self.get_logger().info(f'Slow tick #{self.slow_count}')

def main(args=None):
    rclpy.init(args=args)
    node = MultiTimerNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Exercise 1.3: Advanced Lifecycle Node (Intermediate)

**Learning Objective**: Implement a complex managed node with resource management

#### Problem
Create a managed node that:
- Manages a "camera device" (simulated)
- Only processes data when in ACTIVE state
- Tracks device usage statistics
- Handles configuration parameters

#### Solution
```python
# test: true
import rclpy
from rclpy.lifecycle import LifecycleNode, TransitionCallbackReturn
from rclpy.lifecycle import State, Transition
import time

class CameraNode(LifecycleNode):
    def __init__(self):
        super().__init__('camera_node')
        self.device_connected = False
        self.frame_count = 0
        self.start_time = None

    def on_configure(self, state: State) -> TransitionCallbackReturn:
        self.get_logger().info('Configuring camera device...')
        # Simulate device initialization
        time.sleep(0.5)
        self.device_connected = True
        self.get_logger().info('Camera device configured')
        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state: State) -> TransitionCallbackReturn:
        self.get_logger().info('Activating camera...')
        self.start_time = time.time()

        # Create processing timer
        self.timer = self.create_timer(0.1, self.process_frame)
        self.get_logger().info('Camera activated - processing at 10 FPS')
        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, state: State) -> TransitionCallbackReturn:
        self.get_logger().info('Deactivating camera...')
        self.timer.destroy()
        self.get_logger().info(f'Processed {self.frame_count} frames')
        return TransitionCallbackReturn.SUCCESS

    def on_cleanup(self, state: State) -> TransitionCallbackReturn:
        self.get_logger().info('Cleaning up camera...')
        self.device_connected = False
        return TransitionCallbackReturn.SUCCESS

    def process_frame(self):
        if not self.device_connected:
            self.get_logger().error('Camera not connected!')
            return

        self.frame_count += 1
        if self.frame_count % 10 == 0:
            elapsed = time.time() - self.start_time
            fps = self.frame_count / elapsed
            self.get_logger().debug(f'FPS: {fps:.1f}')

def main(args=None):
    rclpy.init(args=args)
    node = CameraNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Exercise 1.4: Node with Error Handling (Intermediate)

**Learning Objective**: Implement robust error handling in ROS 2 nodes

#### Problem
Create a node that:
- Simulates a potentially failing operation
- Handles exceptions gracefully
- Reports errors without crashing
- Includes a recovery mechanism

#### Solution
```python
# test: true
import rclpy
from rclpy.node import Node
import random

class RobustNode(Node):
    def __init__(self):
        super().__init__('robust_node')
        self.timer = self.create_timer(1.0, self.periodic_operation)
        self.failure_count = 0
        self.max_failures = 5

    def periodic_operation(self):
        try:
            # Simulate operation that might fail
            if random.random() < 0.3:  # 30% chance of failure
                raise RuntimeError("Simulated operation failure")

            # Successful operation
            self.get_logger().info("Operation completed successfully")
            self.failure_count = 0  # Reset on success

        except RuntimeError as e:
            self.failure_count += 1
            self.get_logger().error(f"Operation failed ({self.failure_count}/{self.max_failures}): {str(e)}")

            if self.failure_count >= self.max_failures:
                self.get_logger().fatal("Too many failures - entering safe mode")
                self.timer.destroy()
                self.safe_mode()

        except Exception as e:
            self.get_logger().error(f"Unexpected error: {str(e)}")

    def safe_mode(self):
        """Enter safe mode after too many failures."""
        self.get_logger().warn("Entering safe mode - attempting recovery in 5 seconds...")
        self.recovery_timer = self.create_timer(5.0, self.attempt_recovery)

    def attempt_recovery(self):
        """Attempt to recover from safe mode."""
        self.get_logger().info("Attempting recovery...")
        self.failure_count = 0
        self.recovery_timer.destroy()
        self.timer = self.create_timer(1.0, self.periodic_operation)
        self.get_logger().info("Recovery successful - resuming normal operation")

def main(args=None):
    rclpy.init(args=args)
    node = RobustNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Troubleshooting Steps

- **ImportError**: Ensure ROS 2 environment is sourced (`source /opt/ros/humble/setup.bash`)
- **Node already exists**: Use unique node names or the `--ros-args --remap` option
- **Timer not firing**: Check that `rclpy.spin()` is being called
- **Memory leaks**: Ensure proper cleanup in node destruction

## Summary

In this chapter, we learned:
- How to create basic ROS 2 nodes in both Python and C++
- The four primary lifecycle states and how to manage transitions
- Best practices for parameter handling and configuration
- Common node patterns including managed nodes and error handling
- How to implement robust error handling and recovery mechanisms

Key takeaways:
- Nodes are the fundamental building blocks in ROS 2
- Proper lifecycle management ensures clean resource handling
- Parameters make nodes configurable and reusable
- Error handling is crucial for production robotics systems

In the next chapter, we'll explore ROS 2 topics and services for inter-node communication.