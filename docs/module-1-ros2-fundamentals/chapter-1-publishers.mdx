---
title: "Chapter 1: ROS 2 Publishers and Subscribers"
sidebar_position: 1
description: Learn the fundamental communication pattern in ROS 2 - publishers and subscribers
keywords: ["ROS2", "publishers", "subscribers", "nodes", "topics"]
tags: ["ros2", "fundamentals", "communication"]
---

# Chapter 1: ROS 2 Publishers and Subscribers

In this chapter, we'll explore the most fundamental communication pattern in ROS 2 - the **publish-subscribe model**. This is the backbone of how ROS 2 nodes exchange information.

## Learning Objectives

After completing this chapter, you will:
- Understand what nodes, topics, publishers, and subscribers are
- Create your first ROS 2 publisher and subscriber
- Learn about message types and QoS settings
- Debug common communication issues

## 1.1 Understanding the Publish-Subscribe Model

### Key Concepts

**Nodes** are individual processes that perform computation. In ROS 2, nodes are the basic building blocks of any robotics application.

**Topics** are named buses over which nodes exchange messages. A topic can have multiple publishers and multiple subscribers.

**Publishers** are nodes that send messages to topics.

**Subscribers** are nodes that receive messages from topics.

```python
# Basic publisher concept
# ┌─────────────┐    message    ┌─────────────┐
# │  Publisher  │ ──────────────► │  Subscriber │
# │    Node     │                │    Node     │
│ └─────────────┘                └─────────────┘
│
│            Topic: /robot_status
```

## 1.2 Creating Your First Publisher

Let's create a simple publisher that sends a "Hello World" message every second.

<PersonalizedSection language="python">

### Python Implementation

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimplePublisher(Node):
    def __init__(self):
        super().__init__('simple_publisher')

        # Create publisher with topic name and queue size
        self.publisher_ = self.create_publisher(
            String,
            'hello_topic',
            10
        )

        # Create timer for periodic publishing
        timer_period = 1.0  # seconds
        self.timer = self.create_timer(
            timer_period,
            self.timer_callback
        )
        self.counter = 0

        self.get_logger().info('Simple publisher node initialized')

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World! Count: {self.counter}'

        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')

        self.counter += 1

def main(args=None):
    rclpy.init(args=args)
    simple_publisher = SimplePublisher()

    try:
        rclpy.spin(simple_publisher)
    except KeyboardInterrupt:
        pass
    finally:
        simple_publisher.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

</PersonalizedSection>

<PersonalizedSection language="cpp">

### C++ Implementation

```cpp
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"
#include <chrono>

using namespace std::chrono_literals;

class SimplePublisher : public rclcpp::Node
{
public:
    SimplePublisher() : Node("simple_publisher"), count_(0)
    {
        // Create publisher
        publisher_ = this->create_publisher<std_msgs::msg::String>(
            "hello_topic", 10);

        // Create timer for periodic publishing
        timer_ = this->create_wall_timer(
            1000ms, std::bind(&SimplePublisher::timer_callback, this));

        RCLCPP_INFO(this->get_logger(), "Simple publisher node initialized");
    }

private:
    void timer_callback()
    {
        auto message = std_msgs::msg::String();
        message.data = "Hello World! Count: " + std::to_string(count_);

        publisher_->publish(message);
        RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());

        count_++;
    }

    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
    size_t count_;
};

int main(int argc, char* argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<SimplePublisher>());
    rclcpp::shutdown();
    return 0;
}
```

</PersonalizedSection>

## 1.3 Creating a Subscriber

Now let's create a subscriber that listens to our publisher.

<PersonalizedSection language="python">

### Python Implementation

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimpleSubscriber(Node):
    def __init__(self):
        super().__init__('simple_subscriber')

        # Create subscriber
        self.subscription = self.create_subscription(
            String,
            'hello_topic',
            self.listener_callback,
            10  # Queue size
        )

        self.get_logger().info('Simple subscriber node initialized')

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    simple_subscriber = SimpleSubscriber()

    try:
        rclpy.spin(simple_subscriber)
    except KeyboardInterrupt:
        pass
    finally:
        simple_subscriber.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

</PersonalizedSection>

<PersonalizedSection language="cpp">

### C++ Implementation

```cpp
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

class SimpleSubscriber : public rclcpp::Node
{
public:
    SimpleSubscriber() : Node("simple_subscriber")
    {
        // Create subscriber
        subscription_ = this->create_subscription<std_msgs::msg::String>(
            "hello_topic", 10,
            std::bind(&SimpleSubscriber::topic_callback, this, std::placeholders::_1));

        RCLCPP_INFO(this->get_logger(), "Simple subscriber node initialized");
    }

private:
    void topic_callback(const std_msgs::msg::String::SharedPtr msg) const
    {
        RCLCPP_INFO(this->get_logger(), "I heard: '%s'", msg->data.c_str());
    }

    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
};

int main(int argc, char* argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<SimpleSubscriber>());
    rclcpp::shutdown();
    return 0;
}
```

</PersonalizedSection>

## 1.4 Building and Running

### 1. Create a ROS 2 Package

```bash
# In your ROS 2 workspace
cd src
ros2 pkg create --build-type ament_cmake my_ros2_examples --dependencies rclcpp std_msgs
```

### 2. Add Your Code

Place your Python scripts in the package's `scripts/` directory or C++ files in the `src/` directory.

### 3. Update CMakeLists.txt (for C++)

```cmake
cmake_minimum_required(VERSION 3.8)
project(my_ros2_examples)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)

# Add executable
add_executable(simple_publisher src/simple_publisher.cpp)
ament_target_dependencies(simple_publisher rclcpp std_msgs)

add_executable(simple_subscriber src/simple_subscriber.cpp)
ament_target_dependencies(simple_subscriber rclcpp std_msgs)

# Install targets
install(TARGETS
  simple_publisher
  simple_subscriber
  DESTINATION lib/${PROJECT_NAME}
)

install(
  DIRECTORY scripts
  DESTINATION lib/${PROJECT_NAME}
  PATTERN "*.py" PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE
                            GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE
)

ament_package()
```

### 4. Build the Package

```bash
cd ~/ros2_ws
colcon build --packages-select my_ros2_examples
```

### 5. Source and Run

```bash
# Source the workspace
source ~/ros2_ws/install/setup.bash

# Terminal 1: Run the publisher
ros2 run my_ros2_examples simple_publisher

# Terminal 2: Run the subscriber
ros2 run my_ros2_examples simple_subscriber
```

## 1.5 Common Debugging Commands

```bash
# List all active nodes
ros2 node list

# List all topics
ros2 topic list

# Show topic information
ros2 topic info /hello_topic

# Echo messages on a topic
ros2 topic echo /hello_topic

# Show topic frequency
ros2 topic hz /hello_topic

# List node connections
ros2 node info /simple_publisher
```

## 1.6 Quality of Service (QoS) Settings

ROS 2 introduces QoS policies to control the behavior of data streams:

```python
# Custom QoS profile
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSDurabilityPolicy

custom_qos = QoSProfile(
    depth=10,
    reliability=QoSReliabilityPolicy.RELIABLE,
    durability=QoSDurabilityPolicy.VOLATILE
)

self.publisher_ = self.create_publisher(
    String,
    'reliable_topic',
    custom_qos
)
```

## Summary

In this chapter, you learned:
- The publish-subscribe communication pattern
- How to create ROS 2 publishers and subscribers in both Python and C++
- How to build and run ROS 2 packages
- Basic debugging commands
- Introduction to QoS settings

## Next Steps

In the next chapter, we'll explore ROS 2 **Services** - the request-response communication pattern for one-to-one interactions.

## Exercises

1. Modify the publisher to publish sensor data (e.g., temperature or position)
2. Create multiple subscribers that react differently to the same message
3. Experiment with different QoS settings and observe the behavior
4. Create a publisher-subscriber system for robot joint states