---
title: "باب 2: Navigation اور Path Planning"
sidebar_position: 2
description: "Navigation stacks، path planning algorithms، اور obstacle avoidance سیکھیں"
keywords:
  - navigation
  - path planning
  - SLAM
  - A* algorithm
  - obstacle avoidance
  - ROS 2 Nav2
tags:
  - navigation
  - path-planning
  - mobile-robots
  - autonomy
difficulty_level: intermediate
ros_version: humble
---

# باب 2: Navigation اور Path Planning

## تعارف

<PersonalizedSection level="beginner" rosFamiliarity="novice">
Navigation یہ ہے کہ روبوٹ ایک جگہ سے دوسری جگہ کیسے جاتے ہیں۔ اسے ایسے سمجھیں جیسے آپ کی کار میں GPS navigation ہے - روبوٹ کو نقشہ دیں اور یہ بہترین راستہ تلاش کر لے گا۔
</PersonalizedSection>

<PersonalizedSection level="advanced" rosFamiliarity="expert">
Robot navigation global path planning (معلوم نقشوں میں بہترین راستے تلاش کرنا)، local planning (dynamic obstacles سے بچنا)، اور localization (روبوٹ کی پوزیشن معلوم کرنا) کو یکجا کرتا ہے۔ یہ باب A* اور Dijkstra جیسے classical algorithms، RRT جیسے sampling-based methods، اور ROS 2 Navigation2 stack کا احاطہ کرتا ہے۔
</PersonalizedSection>

## 2.1 نقشے کی نمائندگی

### Occupancy Grid Maps

```python
# test: true
# ROS 2 Humble | Python 3.10
# Dependencies: numpy, nav_msgs
import numpy as np
from nav_msgs.msg import OccupancyGrid

class OccupancyGridMap:
    """Navigation کے لیے occupancy grid map"""

    def __init__(self, width=100, height=100, resolution=0.1):
        self.width = width
        self.height = height
        self.resolution = resolution  # فی سیل میٹر

        # Map initialize کریں (0=خالی، 100=رکاوٹ، -1=نامعلوم)
        self.data = np.zeros((height, width), dtype=np.int8)

    def world_to_grid(self, x, y):
        """World coordinates کو grid indices میں تبدیل کریں"""
        i = int((y - self.origin_y) / self.resolution)
        j = int((x - self.origin_x) / self.resolution)
        return i, j

    def grid_to_world(self, i, j):
        """Grid indices کو world coordinates میں تبدیل کریں"""
        x = j * self.resolution + self.origin_x
        y = i * self.resolution + self.origin_y
        return x, y

    def set_obstacle(self, x, y, radius=0.5):
        """نقشے میں رکاوٹ شامل کریں"""
        i_center, j_center = self.world_to_grid(x, y)
        radius_cells = int(radius / self.resolution)

        for i in range(max(0, i_center - radius_cells),
                      min(self.height, i_center + radius_cells + 1)):
            for j in range(max(0, j_center - radius_cells),
                          min(self.width, j_center + radius_cells + 1)):
                if np.sqrt((i - i_center)**2 + (j - j_center)**2) <= radius_cells:
                    self.data[i, j] = 100  # مقبوضہ

    def is_free(self, x, y):
        """چیک کریں کہ پوزیشن خالی ہے"""
        i, j = self.world_to_grid(x, y)
        if 0 <= i < self.height and 0 <= j < self.width:
            return self.data[i, j] == 0
        return False
```

## 2.2 Global Path Planning

### A* Algorithm

```python
# test: true
# ROS 2 Humble | Python 3.10
# Dependencies: numpy, heapq
import heapq
import numpy as np

class AStarPlanner:
    """Grid maps کے لیے A* path planning algorithm"""

    def __init__(self, grid_map):
        self.map = grid_map
        # 8 سمتوں میں حرکت
        self.movements = [
            (0, 1, 1.0),   # مشرق
            (1, 0, 1.0),   # جنوب
            (0, -1, 1.0),  # مغرب
            (-1, 0, 1.0),  # شمال
            (1, 1, np.sqrt(2)),   # جنوب مشرق
            (1, -1, np.sqrt(2)),  # جنوب مغرب
            (-1, 1, np.sqrt(2)),  # شمال مشرق
            (-1, -1, np.sqrt(2))  # شمال مغرب
        ]

    def heuristic(self, a, b):
        """Heuristic function (Euclidean distance)"""
        return np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)

    def is_valid(self, i, j):
        """چیک کریں کہ سیل درست اور خالی ہے"""
        return (0 <= i < self.map.height and
                0 <= j < self.map.width and
                self.map.data[i, j] < 100)

    def plan(self, start_world, goal_world):
        """A* استعمال کرتے ہوئے شروع سے مقصد تک راستہ بنائیں"""
        # Grid coordinates میں تبدیل کریں
        start_i, start_j = self.map.world_to_grid(*start_world)
        goal_i, goal_j = self.map.world_to_grid(*goal_world)

        if not self.is_valid(start_i, start_j) or not self.is_valid(goal_i, goal_j):
            return None  # غلط شروع یا مقصد

        # Priority queue
        open_set = [(0, 0, (start_i, start_j))]
        g_score = { (start_i, start_j): 0 }
        parent = {}
        closed_set = set()

        while open_set:
            _, _, (i, j) = heapq.heappop(open_set)

            if (i, j) == (goal_i, goal_j):
                # راستہ بنائیں
                path = []
                current = (i, j)
                while current in parent:
                    path.append(self.map.grid_to_world(*current))
                    current = parent[current]
                path.append(self.map.grid_to_world(start_i, start_j))
                return path[::-1]  # الٹا راستہ

            closed_set.add((i, j))

            # پڑوسیوں کو چیک کریں
            for di, dj, cost in self.movements:
                ni, nj = i + di, j + dj

                if not self.is_valid(ni, nj) or (ni, nj) in closed_set:
                    continue

                tentative_g = g_score[(i, j)] + cost

                if (ni, nj) not in g_score or tentative_g < g_score[(ni, nj)]:
                    parent[(ni, nj)] = (i, j)
                    g_score[(ni, nj)] = tentative_g
                    f_score = tentative_g + self.heuristic((ni, nj), (goal_i, goal_j))
                    heapq.heappush(open_set, (f_score, len(open_set), (ni, nj)))

        return None  # کوئی راستہ نہیں ملا
```

## 2.3 Sampling-Based Planners

### RRT (Rapidly-exploring Random Tree)

```python
# test: true
# ROS 2 Humble | Python 3.10
# Dependencies: numpy
import numpy as np

class RRTPlanner:
    """RRT sampling-based path planner"""

    def __init__(self, grid_map, max_iter=5000, step_size=0.5):
        self.map = grid_map
        self.max_iter = max_iter
        self.step_size = step_size

    def plan(self, start_world, goal_world, goal_tolerance=0.5):
        """RRT استعمال کرتے ہوئے راستہ بنائیں"""
        start = np.array(start_world)
        goal = np.array(goal_world)

        # درخت شروع کریں
        nodes = [start]
        parent = {0: None}

        for iteration in range(self.max_iter):
            # Random point sample کریں
            if np.random.random() < 0.1:  # 10% موقع مقصد کی طرف
                sample = goal
            else:
                sample = self.sample_free()

            # قریب ترین node تلاش کریں
            nearest_idx = self.find_nearest(nodes, sample)

            # Sample کی طرف steer کریں
            new_node = self.steer(nodes[nearest_idx], sample)

            # چیک کریں کہ نیا node درست ہے
            if self.is_collision_free(nodes[nearest_idx], new_node):
                new_idx = len(nodes)
                nodes.append(new_node)
                parent[new_idx] = nearest_idx

                # چیک کریں کہ مقصد تک پہنچ گئے
                if np.linalg.norm(new_node - goal) < goal_tolerance:
                    # راستہ بنائیں
                    path = [goal]
                    current_idx = new_idx
                    while current_idx is not None:
                        path.append(nodes[current_idx])
                        current_idx = parent[current_idx]
                    return path[::-1]

        return None  # کوئی راستہ نہیں ملا

    def sample_free(self):
        """Random خالی configuration sample کریں"""
        while True:
            x = np.random.uniform(-5, 5)
            y = np.random.uniform(-5, 5)
            if self.map.is_free(x, y):
                return np.array([x, y])

    def find_nearest(self, nodes, point):
        """درخت میں قریب ترین node تلاش کریں"""
        distances = [np.linalg.norm(node - point) for node in nodes]
        return np.argmin(distances)

    def steer(self, from_node, to_node):
        """ایک node سے دوسرے کی طرف steer کریں"""
        direction = to_node - from_node
        distance = np.linalg.norm(direction)

        if distance <= self.step_size:
            return to_node
        else:
            unit_direction = direction / distance
            return from_node + unit_direction * self.step_size
```

## 2.4 Local Path Planning

### Dynamic Window Approach (DWA)

```python
# test: true
# ROS 2 Humble | Python 3.10
# Dependencies: numpy

class DWAPlanner:
    """Local planning کے لیے Dynamic Window Approach"""

    def __init__(self, robot):
        self.robot = robot
        self.max_v = 1.0  # زیادہ سے زیادہ linear velocity (m/s)
        self.max_w = 1.0  # زیادہ سے زیادہ angular velocity (rad/s)

        # Simulation parameters
        self.dt = 0.1
        self.predict_time = 2.0

        # Weights
        self.weight_heading = 1.0
        self.weight_dist = 1.0
        self.weight_velocity = 1.0

    def plan(self, current_pose, goal_pose, obstacles, current_v=0, current_w=0):
        """DWA استعمال کرتے ہوئے local trajectory بنائیں"""
        best_traj = None
        best_vw = (0, 0)
        best_score = -float('inf')

        # Velocity window بنائیں
        v_range = np.arange(0, self.max_v, 0.1)
        w_range = np.arange(-self.max_w, self.max_w, 0.1)

        for v in v_range:
            for w in w_range:
                # Trajectory کی پیشگوئی کریں
                traj = self.predict_trajectory(current_pose, v, w, self.predict_time)

                # Trajectory کا جائزہ لیں
                score = self.evaluate_trajectory(traj, goal_pose, obstacles, v)

                if score > best_score:
                    best_score = score
                    best_traj = traj
                    best_vw = (v, w)

        return best_vw, best_traj

    def predict_trajectory(self, pose, v, w, predict_time):
        """روبوٹ trajectory کی پیشگوئی کریں"""
        traj = [pose.copy()]
        x, y, theta = pose
        t = 0

        while t < predict_time:
            x += v * np.cos(theta) * self.dt
            y += v * np.sin(theta) * self.dt
            theta += w * self.dt
            traj.append(np.array([x, y, theta]))
            t += self.dt

        return np.array(traj)
```

## 2.5 ROS 2 Navigation2 Integration

### Nav2 استعمال کرنا

```python
# test: true
# ROS 2 Humble | Python 3.10
# Dependencies: nav2_simple_commander
from nav2_simple_commander.robot_navigator import BasicNavigator
from geometry_msgs.msg import PoseStamped
import rclpy

def navigate_to_goal():
    rclpy.init()
    navigator = BasicNavigator()

    # Initial pose سیٹ کریں
    initial_pose = PoseStamped()
    initial_pose.header.frame_id = 'map'
    initial_pose.pose.position.x = 0.0
    initial_pose.pose.position.y = 0.0
    initial_pose.pose.orientation.w = 1.0

    navigator.setInitialPose(initial_pose)
    navigator.waitUntilNav2Active()

    # Goal pose سیٹ کریں
    goal_pose = PoseStamped()
    goal_pose.header.frame_id = 'map'
    goal_pose.pose.position.x = 5.0
    goal_pose.pose.position.y = 3.0
    goal_pose.pose.orientation.w = 1.0

    # Navigate کریں
    navigator.goToPose(goal_pose)

    while not navigator.isTaskComplete():
        feedback = navigator.getFeedback()
        print(f"باقی فاصلہ: {feedback.distance_remaining:.2f} میٹر")

    result = navigator.getResult()
    print(f"نتیجہ: {result}")

    rclpy.shutdown()

if __name__ == '__main__':
    navigate_to_goal()
```

## خلاصہ

اس باب میں ہم نے سیکھا:
- Occupancy grid maps اور costmaps
- Global planning algorithms: A*، Dijkstra
- Sampling-based planners: RRT
- Local planning with DWA
- ROS 2 Navigation2 integration

اہم نکات:
- Global planners معلوم نقشوں میں بہترین راستے تلاش کرتے ہیں
- Local planners dynamic obstacles سے بچتے ہیں
- Sampling-based methods high-dimensional spaces میں اچھے کام کرتے ہیں
- Nav2 مکمل navigation stack فراہم کرتا ہے

:::info اگلا باب
[باب 3: Perception](/docs/module-3-applications/chapter-3-perception) میں ہم سینسر fusion اور object detection سیکھیں گے۔
:::
